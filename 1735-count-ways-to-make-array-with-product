class Solution {
    static final int MOD = 1_000_000_007;
    static final int MAX = 10005;
    static long[] factorial = new long[MAX];
    static long[] inverse = new long[MAX];

    // Precompute factorials and inverse factorials
    static {
        factorial[0] = 1;
        for (int i = 1; i < MAX; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        inverse[MAX - 1] = modInverse(factorial[MAX - 1]);
        for (int i = MAX - 2; i >= 0; i--) {
            inverse[i] = inverse[i + 1] * (i + 1) % MOD;
        }
    }

    public List<Integer> waysToFillArray(int[][] queries) {
        List<Integer> res = new ArrayList<>();
        for (int[] q : queries) {
            int n = q[0], k = q[1];
            Map<Integer, Integer> primeFactors = getPrimeFactors(k);
            long ans = 1;
            for (int exp : primeFactors.values()) {
                ans = ans * nCr(n + exp - 1, exp) % MOD;
            }
            res.add((int) ans);
        }
        return res;
    }

    // Helper to compute nCr % MOD
    private long nCr(int n, int r) {
        return factorial[n] * inverse[r] % MOD * inverse[n - r] % MOD;
    }

    // Modular inverse using Fermat's little theorem
    private static long modInverse(long x) {
        return modPow(x, MOD - 2);
    }

    private static long modPow(long x, int n) {
        long result = 1;
        while (n > 0) {
            if ((n & 1) == 1) result = result * x % MOD;
            x = x * x % MOD;
            n >>= 1;
        }
        return result;
    }

    // Prime factorization
    private Map<Integer, Integer> getPrimeFactors(int x) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 2; i * i <= x; i++) {
            while (x % i == 0) {
                map.put(i, map.getOrDefault(i, 0) + 1);
                x /= i;
            }
        }
        if (x > 1) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }
        return map;
    }
}
