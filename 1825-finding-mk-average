import java.util.*;

public class MKAverage {

    private final int m, k;

    private long midSum = 0;

    private final Queue<Integer> queue = new ArrayDeque<>();
    private final TreeMap<Integer, Integer> low = new TreeMap<>();
    private final TreeMap<Integer, Integer> mid = new TreeMap<>();
    private final TreeMap<Integer, Integer> high = new TreeMap<>();

    private int lowSize = 0, midSize = 0, highSize = 0;

    public MKAverage(int m, int k) {
        this.m = m;
        this.k = k;
    }

    public void addElement(int num) {
        queue.add(num);

        // Insert into the correct bucket (critical fix)
        if (!low.isEmpty() && num <= low.lastKey()) {
            add(low, num);
            lowSize++;
        } 
        else if (!high.isEmpty() && num >= high.firstKey()) {
            add(high, num);
            highSize++;
        } 
        else {
            add(mid, num);
            midSize++;
            midSum += num;
        }

        if (queue.size() > m) {
            int old = queue.poll();
            removeFromAll(old);
        }

        rebalance();
    }

    public int calculateMKAverage() {
        if (queue.size() < m) return -1;
        return (int) (midSum / (m - 2 * k));
    }

    /* helper methods */
    private void removeFromAll(int x) {
        if (remove(low, x)) {
            lowSize--;
        } else if (remove(high, x)) {
            highSize--;
        } else if (remove(mid, x)) {
            midSize--;
            midSum -= x;
        }
    }

    private void rebalance() {

        // low must contain exactly k smallest
        while (lowSize > k) {
            int v = low.lastKey();
            remove(low, v);
            lowSize--;
            add(mid, v);
            midSize++;
            midSum += v;
        }

        while (lowSize < k && midSize > 0) {
            int v = mid.firstKey();
            remove(mid, v);
            midSize--;
            midSum -= v;
            add(low, v);
            lowSize++;
        }

        // high must contain exactly k largest
        while (highSize > k) {
            int v = high.firstKey();
            remove(high, v);
            highSize--;
            add(mid, v);
            midSize++;
            midSum += v;
        }

        while (highSize < k && midSize > 0) {
            int v = mid.lastKey();
            remove(mid, v);
            midSize--;
            midSum -= v;
            add(high, v);
            highSize++;
        }
    }

    private void add(TreeMap<Integer, Integer> map, int x) {
        map.put(x, map.getOrDefault(x, 0) + 1);
    }

    private boolean remove(TreeMap<Integer, Integer> map, int x) {
        Integer cnt = map.get(x);
        if (cnt == null) return false;
        if (cnt == 1) map.remove(x);
        else map.put(x, cnt - 1);
        return true;
    }
}
