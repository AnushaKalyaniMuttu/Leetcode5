import java.util.*;

class Solution {
    static class Point {
        double x, y;
        Point(double x, double y) { this.x = x; this.y = y; }
    }

    static class Circle {
        Point center;
        double radius;
        Circle(Point c, double r) { center = c; radius = r; }
    }

    public double[] outerTrees(int[][] trees) {
        List<Point> pts = new ArrayList<>();
        for (int[] t : trees) pts.add(new Point(t[0], t[1]));

        Collections.shuffle(pts);  // randomize for expected linear time
        Circle c = welzl(pts, new ArrayList<>(), pts.size());
        return new double[]{c.center.x, c.center.y, c.radius};
    }

    private Circle welzl(List<Point> pts, List<Point> boundary, int n) {
        if (n == 0 || boundary.size() == 3) {
            return trivial(boundary);
        }
        Circle d = welzl(pts, boundary, n - 1);
        Point p = pts.get(n - 1);
        if (outside(d, p)) {
            boundary.add(p);
            d = welzl(pts, boundary, n - 1);
            boundary.remove(boundary.size() - 1);
        }
        return d;
    }

    private Circle trivial(List<Point> boundary) {
        if (boundary.isEmpty()) return new Circle(new Point(0, 0), 0);
        if (boundary.size() == 1) return new Circle(boundary.get(0), 0);

        if (boundary.size() == 2) {
            Point a = boundary.get(0), b = boundary.get(1);
            Point center = new Point((a.x + b.x) / 2, (a.y + b.y) / 2);
            double r = Math.hypot(a.x - b.x, a.y - b.y) / 2;
            return new Circle(center, r);
        }

        // 3 points -> circle through all three
        Point a = boundary.get(0), b = boundary.get(1), c = boundary.get(2);
        double d = 2 * (a.x * (b.y - c.y) +
                        b.x * (c.y - a.y) +
                        c.x * (a.y - b.y));

        if (Math.abs(d) < 1e-12) // collinear
            return new Circle(a, 0);

        double ux = ((a.x*a.x + a.y*a.y) * (b.y - c.y) +
                     (b.x*b.x + b.y*b.y) * (c.y - a.y) +
                     (c.x*c.x + c.y*c.y) * (a.y - b.y)) / d;

        double uy = ((a.x*a.x + a.y*a.y) * (c.x - b.x) +
                     (b.x*b.x + b.y*b.y) * (a.x - c.x) +
                     (c.x*c.x + c.y*c.y) * (b.x - a.x)) / d;

        Point center = new Point(ux, uy);
        double r = Math.hypot(center.x - a.x, center.y - a.y);
        return new Circle(center, r);
    }

    private boolean outside(Circle c, Point p) {
        return Math.hypot(p.x - c.center.x, p.y - c.center.y) > c.radius + 1e-9;
    }
}
