import java.util.*;

public class Solution {

    public int maxBuilding(int n, int[][] restrictions) {
        List<int[]> list = new ArrayList<>();

        // Building 1 is always height 0
        list.add(new int[]{1, 0});

        // Add given restrictions
        for (int[] r : restrictions) {
            list.add(r);
        }

        // If n is not in restrictions, add a "soft" restriction
        // Maximum possible height of building n is (n-1) due to slope from building 1
        boolean hasN = false;
        for (int[] r : list) {
            if (r[0] == n) {
                hasN = true;
                break;
            }
        }
        if (!hasN) {
            list.add(new int[]{n, n - 1});
        }

        // Sort restrictions by building index
        list.sort(Comparator.comparingInt(a -> a[0]));

        // Forward pass
        for (int i = 1; i < list.size(); i++) {
            int[] prev = list.get(i - 1);
            int[] curr = list.get(i);
            curr[1] = Math.min(curr[1], prev[1] + (curr[0] - prev[0]));
        }

        // Backward pass
        for (int i = list.size() - 2; i >= 0; i--) {
            int[] next = list.get(i + 1);
            int[] curr = list.get(i);
            curr[1] = Math.min(curr[1], next[1] + (next[0] - curr[0]));
        }

        // Compute maximum peak between pairs
        int max = 0;
        for (int i = 1; i < list.size(); i++) {
            int[] L = list.get(i - 1);
            int[] R = list.get(i);

            int d = R[0] - L[0];
            int peak = (L[1] + R[1] + d) / 2;
            max = Math.max(max, peak);
        }

        return max;
    }
}
