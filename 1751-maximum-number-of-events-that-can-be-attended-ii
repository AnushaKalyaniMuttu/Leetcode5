class Solution {
    public int maxValue(int[][] events, int k) {
        Integer[][] memo = new Integer[events.length][k + 1];
        Arrays.sort(events, (a, b) -> a[0] == b[0] ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));
        return dfs(events, 0, k, memo);
    }

    private int dfs(int[][] events, int i, int k, Integer[][] memo) {
        if (i == events.length || k == 0) {
            return 0;
        }
        if (memo[i][k] != null) {
            return memo[i][k];
        }

        // Option 1: skip this event
        int ans = dfs(events, i + 1, k, memo);

        // Option 2: take this event
        int nextIndex = firstGreaterEqual(events, i + 1, events[i][1] + 1);
        ans = Math.max(ans, events[i][2] + dfs(events, nextIndex, k - 1, memo));

        memo[i][k] = ans;
        return ans;
    }

    // binary search: find first index j >= l such that events[j][0] >= target
    private int firstGreaterEqual(int[][] events, int l, int target) {
        int r = events.length;
        while (l < r) {
            int m = l + (r - l) / 2;
            if (events[m][0] >= target) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return l;
    }
}
