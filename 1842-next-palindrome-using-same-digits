public class NextPalindromeUsingSameDigits {

    public String nextPalindrome(String num) {
        int n = num.length();
        if (n <= 3) return "";  // Cannot form a larger palindrome

        char[] arr = num.toCharArray();
        int half = n / 2;

        // Extract left half
        char[] left = new char[half];
        for (int i = 0; i < half; i++) {
            left[i] = arr[i];
        }

        // Get next permutation of left half
        if (!nextPermutation(left)) {
            return "";  // No larger permutation possible
        }

        // Build the new palindrome
        String leftPart = new String(left);
        StringBuilder sb = new StringBuilder();
        sb.append(leftPart);

        // Add middle char if odd length
        if (n % 2 == 1) {
            sb.append(arr[half]);
        }

        // Mirror left half
        sb.append(new StringBuilder(leftPart).reverse());

        return sb.toString();
    }

    private boolean nextPermutation(char[] arr) {
        int n = arr.length;
        int i = n - 2;

        // Find first decreasing element from right
        while (i >= 0 && arr[i] >= arr[i + 1]) {
            i--;
        }
        if (i < 0) return false;

        // Find element just larger than arr[i]
        int j = n - 1;
        while (arr[j] <= arr[i]) {
            j--;
        }

        // Swap
        swap(arr, i, j);

        // Reverse suffix
        reverse(arr, i + 1, n - 1);
        return true;
    }

    private void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private void reverse(char[] arr, int l, int r) {
        while (l < r) {
            swap(arr, l, r);
            l++;
            r--;
        }
    }
}
