import java.util.*;

class Solution {
    
    // Helper function to simulate the spread of malware
    // Returns the number of infected nodes in the graph starting from initially infected nodes
    private int spread(int[][] graph, int[] initial, int[] nodesToRemove) {
        int n = graph.length;
        boolean[] infected = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        
        // Initialize the queue with the initial infected nodes, excluding any nodes to be removed
        Set<Integer> toRemove = new HashSet<>();
        for (int node : nodesToRemove) {
            toRemove.add(node);
        }
        
        // Initialize the queue with the initial infected nodes
        for (int node : initial) {
            if (!infected[node] && !toRemove.contains(node)) {
                queue.offer(node);
                infected[node] = true;
            }
        }

        int infectedCount = 0;  // Count infected nodes
        while (!queue.isEmpty()) {
            int node = queue.poll();
            infectedCount++;
            
            // Check all neighbors of this node
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (graph[node][neighbor] == 1 && !infected[neighbor] && !toRemove.contains(neighbor)) {
                    infected[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        
        return infectedCount;
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;

        // Sort initial array for lexicographical order (smallest index node first)
        Arrays.sort(initial);
        
        // Step 1: Calculate the number of infected nodes if no node is removed
        int initialSpread = spread(graph, initial, new int[0]);

        // Step 2: For each node in initial, try removing it and check the result
        int minInfected = Integer.MAX_VALUE;
        int resultNode = -1;
        
        // Try removing each node in the initial infected list
        for (int i = 0; i < initial.length; i++) {
            // Remove node i from initial
            int[] modifiedInitial = new int[initial.length - 1];
            int idx = 0;
            for (int j = 0; j < initial.length; j++) {
                if (j != i) {
                    modifiedInitial[idx++] = initial[j];
                }
            }
            
            // Calculate the number of infected nodes after removal of node `i`
            int spreadAfterRemoval = spread(graph, modifiedInitial, new int[]{initial[i]});
            
            // We want to minimize the spread, and in case of a tie, return the smallest index node
            if (spreadAfterRemoval < minInfected) {
                minInfected = spreadAfterRemoval;
                resultNode = initial[i];
            }
        }

        return resultNode;
    }
}
