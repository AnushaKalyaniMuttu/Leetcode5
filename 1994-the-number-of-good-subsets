import java.util.*;

public class Solution {

    public int numberOfGoodSubsets(int[] nums) {
        int MOD = 1_000_000_007;

        int[] freq = new int[31];
        for (int num : nums) freq[num]++;

        int[] primes = {2,3,5,7,11,13,17,19,23,29};
        Map<Integer, Integer> numToMask = new HashMap<>();

        // Precompute masks for valid numbers
        for (int num = 2; num <= 30; num++) {
            int x = num, mask = 0;
            boolean valid = true;

            for (int i = 0; i < primes.length; i++) {
                int count = 0;
                while (x % primes[i] == 0) {
                    x /= primes[i];
                    count++;
                }
                if (count > 1) { // squared prime factor
                    valid = false;
                    break;
                }
                if (count == 1) mask |= (1 << i);
            }

            if (valid && x == 1) numToMask.put(num, mask);
        }

        long[] dp = new long[1 << 10];
        dp[0] = 1;

        for (int num = 2; num <= 30; num++) {
            if (!numToMask.containsKey(num) || freq[num] == 0) continue;
            int mask = numToMask.get(num);

            for (int state = (1 << 10) - 1; state >= 0; state--) {
                if ((state & mask) == 0) {
                    dp[state | mask] = (dp[state | mask] + dp[state] * freq[num]) % MOD;
                }
            }
        }

        long result = 0;
        for (int i = 1; i < (1 << 10); i++) result = (result + dp[i]) % MOD;

        // Multiply by 2^count(1)
        int ones = freq[1];
        long pow = 1, base = 2;
        while (ones > 0) {
            if ((ones & 1) == 1) pow = (pow * base) % MOD;
            base = (base * base) % MOD;
            ones >>= 1;
        }

        result = (result * pow) % MOD;

        return (int) result;
    }
}
